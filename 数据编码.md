# 信息编码

## 运算方法和电路

### 1.加法器和ALU

**输入：**

- 两个运算数
- 进位标志cin

**输出：**

- 结果
- 4个标志位

### 2.加减运算



### 3.乘除运算

**乘法：**

- ALU：对乘积寄存器和被乘数做加法，并产生进位
- 控制逻辑：循环计数；控制加法和移位操作；
- 







## 整数表示

### 1.无符号数

二进制编码加权相加

### 2.有符号数

**（1）补码：** **最高位作为负权**，后面作为正权，按位相加

因此补码表示的最小值：-2^(w-1),最大值为2^(w-1)-1

**（2）原码：** **最高位作为符号位**，后面和无符号数一致

**（3）反码：** **最高位的权为 —(2^(w-1)-1)**，其它与补码一致

### 3.无符号和有符号之间的转换

- 二进制表示不会改变，改变了解释这些二进制位的方式

例如：int x=-8 ,则unsigned short y=(unsigned short) x;

则y=8

### 4.位拓展&截断

- 算术右移：针对补码，进行符号拓展

- 逻辑右移：针对无符号数，进行零拓展



**截断**

如int ——> short:直接将前16位截断，重新将得到的二进制补码表示转换为十进制



## 整数运算

### 溢出判断

- **无符号数**

**结论：**判断溢出<=> 运算结果s< x or y时

s=x+y mod 2^w(w为A，B的位数)

**标志位：**

**CF**标志表示无符号数加减法时是否有溢出：1表示溢出

大题要求写过程：CF=Cout^Cin:当做减法时，Cin=1；当有进位输出时，Cout=1

小题可直接判断



- **补码**

**结论**：两**符号相同**的数相加才会发生溢出，当且仅当**结果**的符号与加数的符号**不一致**时，发生溢出

上溢出（正溢出）：s>=2^(w-1)

下溢出（负溢出）：s<-2^(w-1)

**标志位：**

**OF**标志表示有符号数运算时是否溢出：1表示溢出

OF=Cn^Cn-1,(Cn和Cn-1为最高位和次高位)

### 1.补码加法

s=x+y mod 2^w

s=x+(-y) mod 2^w

### 2.补码非

—x=~x+1(取反加1)



### 3.补码乘法

(x*y) mod 2^w

再将上述无符号数转换成补码表示

即展开为二进制表示后，按位相乘得到结果后直接截断w位

与无符号运算法则相同

32位*32位时：当高32位不是全0或者全1时，发生了溢出

**实现：**

**1.利用加法指令**

- 要调用其它指令，执行时间最长

**2.ALU+控制逻辑运算电路**



**3.阵列乘法器**

- 并行乘法，三种方法内效率最高

### 4.补码除法



## 浮点数

### 1.浮点数表示

不是所有浮点数都能被二进制表示

**IEEE754：（-1）^s *M *(2^E)**

- float:32bits单精度；double:64bits双精度

- s：符号位

- E：exp!=0&2^k-1时，e-(2^(k-1)-1);exp=0时，1-（2^(k-1)-1）.

​	  k为exp部分所占位数（float:8bits;double:11bits）

- M：exp!=0&2^k-1时，1+f，f为编码部分中的小数部分（float:23bits;double:52bits）;exp=0时，f

**注：f和e都是用原码表示，没有正负**

特殊的数的表示：

NaN：阶码全1，尾数全0

0：阶码全0，尾数全0





溢出问题：尾数上溢出时，阶数+1。阶码全1，上溢；全0，下溢



### 2.浮点数运算

- 对阶：将阶码小的尾数向右移，阶码+右移的位数，直到和大阶相等

- 尾数运算：纯小数定点加减运算，要带上默认的1

- 规格化：

将尾数向左or向右移位，直到1.xxx的形式，同时阶数增加移动的位数

- 舍入：尾数求和时超出表示范围

> .eg:
>
> float a=0.3;b=1.6;
>
> a=(0.3)10=(0011 1110 1001 1001 1001 1001 1001 1010)2   Sa=0  Ea=011 1110 1  Ma=1.001 1001 1001 1001 1001 1010
>
> b=(1.6)10=(0011 1111 1100 1100 1100 1100 1100 1101)2    Sb=0  Eb=011 1111 1   Mb=1.100 1100 1100 1100 1100 1101
>
> a+b=?
>
> 第一步：对阶
>
> ∵ Ea<Eb  Eb-Ea=2
>
> ∴ Ma要调整为 0.0 1001 1001 1001 1001 1001 10    10
>
>   E=011 1111 1
>
> 第二步：尾数运算
>
>   0.01001100110011001100110
>
> \+ 1.10011001100110011001101
>
>   1.11100110011001100110011‬
>
> 第三步：规格化
>
> 1.11100110011001100110011‬已经是个规格化数据了
>
> 第四步：舍入处理
>
> 由于在对阶时，Ma有右移，且第一次最高为1，第二次为0，所以按"0舍1入"，尾数运算结果调整为 1.11100110011001100110100
>
> 第五步：溢出判断
>
> 没有溢出，阶码不调整，所以最后的结果为
>
> a+b=(0 01111111 11100110011001100110100)2=(0011 1111 1111 0011 0011 0011 0011 0100)2=(3FF33334)16
>
> 转为10进制
>
> a+b=1.90000010







高精度+低精度

### 3.整数与浮点数之间的转换

不用考虑表示方法上的差异

- float转int，小数部分会被舍去
- int转float，32位到24位也会有损失，但是如果int整数有效位小于24位，则可以
- float转double：低精度转高精度，没问题

## 