# 树

### 一些基本概念：

*** 双亲**：

*** 度**：结点的度为一个结点的孩子个数

*** 树的度**：结点的最大度数

*** 深度：**自顶向下累加

*** 高度：**自底向上累加

*** 路径长度：**



## 二叉树

可以为空

### * 存储结构：





### * 遍历：

1、 先序

```c++
visit(node);
node->left;//递归
node->right;//递归
```



2、 中序

```c++
node->left;//递归
visit(node);
node->right;//递归
```



3、 后序

```c++
x node->left;//递归
visit(node);
node->right;//递归
```

根据遍历序列构造二叉树：

前序序列为入栈顺序，中序序列为出栈序列，可以唯一确定一棵二叉树

### * 线索二叉树（非重点）：

- 按照遍历顺序搞清楚谁是谁的直接前驱和后继即可





---



## 树和森林



### * 存储结构：

#### 1、 双亲表示

- 一维数组存储每个结点
- 每个结点中有伪指针指向双亲结点的下标
- 根节点下标为0，指针为-1

#### 2、 孩子表示





#### 3、孩子兄弟表示



### * 与二叉树之间的转换：

#### 1、 单棵树与二叉树：

转换成的二叉树的根节点一定没有右孩子

#### 2、 森林与二叉树

单棵树转换成二叉树后，每个根节点之间相连，最后以第一棵树的根为根节点

转换关系是唯一的

### * 遍历：

**树的遍历：**

- 先根遍历：先访问根结点，再依次访问其子树   <=>对应二叉树的先序
- 后根遍历：先遍历子树，再访问根节点    <=>对应二叉树的中序

**森林的遍历：**

- 先序遍历：对应二叉树的先序
- 中序遍历：对应二叉树的中序
- 因此根据森林的遍历，可以构造出对应二叉树，从而得出二叉树的后根遍历

## 应用：

#### 1、 并查集



- 初始化：每个元素单独成一个集合
- 每个节点的双亲结点的下标为该结点的值
- 根节点的双亲结点为负数
- 数组下标为元素名

```c++
void find(int x)
{
    while(p[x]>=0)x=p[x];
    return x;
}
void unite(int root1,int root2)
{
    p[root2]=root1;//root2集合接到root1上
}
```



#### 2、 哈夫曼树

wpl=所有叶节点的带权路径长度=Σwi*li(li为根节点到i结点的路径长度)

wpl最小的二叉树=>哈夫曼树（aka 最优二叉树）

- 构造：选两个权值最小的结点合并成一个树，该树的根结点权值为这两个结点的和，将根节点与剩余的结点进行比较，再选两个最小的合并成一个树，递归下去

  ![image-20221026171433206](C:\Users\gjys\AppData\Roaming\Typora\typora-user-images\image-20221026171433206.png)

- 编码：用可变长度编码，对频率高的字符用短编码，对频率低的字符用长编码，从而使数据的平均编码长度降低，起到压缩数据

  前缀编码：一个编码不是任何一个编码的前缀
  
  用哈夫曼树给需要编码的字符集编码：每个字符集出现的频度即为其权重，按照权重构造哈夫曼树
  
  往左为0，往右为1，得到到每一个叶节点（各字符）的编码，即为哈夫曼编码
  
  **注：符号数为n，则对应哈夫曼树的结点数为2n-1**