# 内存管理



## 基本概念

- 逻辑空间与物理空间
- 地址变换
- 内存共享
- 内存保护





## 程序的装入和链接

- 编译：.c/.cpp->.obj
- 链接：.obj->.exe；修改相对地址，并将外部调用符号变换成相对地址
- 装入：.exe->内存

### 1.装入

（1）绝对装入

- 只适合单道程序
- 程序中的逻辑地址与实际内存地址一致

（2）可重定位装入（静态）

- 装入时完成逻辑地址到物理地址的转换（**由软件完成**）
- 逻辑地址采用相对寻址，首地址为0

（3）动态运行时装入

- 要访问数据时才进行地址变换（即指令执行时）
- 地址映射硬件上需要一对寄存器支持，**软硬件结合完成**

### 2.链接

（1）静态链接

编程时，链接所有模块

（2）装入时动态链接

边装入，边链接

（3）运行时动态链接

运行时，**根据需要**链接模块



## 内存分配方式

### 1.连续分配

#### （1）单一连续分配

- 内存分为系统区和用户区
- 用户区一个用户程序**独占**
- 只适合单任务OS

#### （2）固定分区

- 内存用户分区划分为若干固定大小的区域，每个分区装**一个作业**
- 分区大小不相等的，要建立一张分区说明表（分区始址、大小、状态）
- 易产生内部碎片，无外部碎片

#### （3）动态分区分配

容易产生外部碎片（小的内存块，放不下进程），可以通过紧凑技术对其进行整理

应该没有内部碎片（？）

1.首次适应

- 按**地址递增**顺序找到第一个符合要求的空闲分区
- 内存低地址地区容易出现外部碎片

2.邻近适应

- 在首次适应的基础上，从上次查找结束的位置继续查找
- 内存空间的尾部分裂成小碎片

3.最佳适应

- 空闲分区**按容量递增**查找，找到第一个空闲分区
- 产生**最多的外部碎片**

4.最坏适应

- 空闲分区**按容量递减**查找，即找到最大的空闲分区
- 导致没有可用的大分区，性能也比较差

### 2.离散分配

#### （1）分页存储

1.基本分页

进程和内存**以块为单位**进行划分，因此不会产生外部碎片。但是会产生内部碎片（即进程的最后一部分小于一个块的容量）。

1）进程中的块成为page，内存中的块成为frame，外存中的块成为block

- 每个进程都有1张页表（页号+物理块号（物理页号））
- 多级页表机制中，顶级页表**最多只能有1个页面（针对一个进程来讲）**

2）多级页表：

顶级页目录表中存储的是**页表的基地址**，再根据页表号找到对应的页表项。页表中存储物理块号，物理块号×页大小+页内偏移即为目标字节数据

![img](https://img-blog.csdnimg.cn/20200609141412766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTAxNjM3,size_16,color_FFFFFF,t_70)



**2.请求分页**

- 缺页中断虽然叫中断，但是属于内部异常
- 地址结构：虚页号+页内偏移量

**驻留集**

- 给一个进程分配的页框的集合

**内存分配策略：**

- 固定分配 局部置换：驻留集数量不变，该进程发生缺页，也在其驻留集内进行置换
- 可变分配 全局置换：驻留集数量在运行过程中可变，发生缺页时，os从空闲块中分配一块
- 可变分配 局部置换：只允许在其驻留集内进行置换

**页面调度算法：**

（1）OPT算法

- 选择未来最久不被使用的页面进行置换（预测）

（2）FIFO算法

- 选择最早进入的页面
- Belady异常：物理块数增大，但是缺页次数不减反增

（3）LRU算法

- 最长时间没被访问的

（4）CLOCK算法

- 访问位A：首次被装入or访问时，置1；
- 替换时，从上到下循环扫描，若A=0，则淘汰；若A=1，则置0

（5）改进型CLOCK

- 增加修改位M
- 从当前指针位置开始循环扫描（M，A），找（0,0）的页面
- 若没有（0，0），再次进行扫描，找（0，1），并将A=0
- 若没有，再来一次，肯定能找到（因为上一步中所有的页面的A=0）

**抖动&工作集**

-  抖动：频繁的页面调度：刚换进就要换出
- 由于每个进程的驻留集太少，即**内存中进程太多（根本原因）**

  因此解决的**唯一**办法是：撤销部分进程

- 工作集：某段时间内，进程要访问的页面的集合
- 由工作时间 t 和工作集窗口W确定工作集：t时刻往前W个页面即为工作集窗口
- 驻留集>工作集



**虚存性能影响因素：**

- 页面大小
- 缺页率
- 工作集
- 置换算法
- 程序编制方法：局部性程度越高，缺页率越低

#### （2）分段存储

1.基本分段

- 地址结构：段号+段内偏移
- 段表项（段号，段长，本段在内存中的基址）
- 若段内偏移量>段长，产生越界中断



2.请求分段





3.段共享与保护：

- 两个作业各自的段表的表项（各自段表中的段号可能不同）指向同一个物理块
- 只会保存一个物理副本



#### （3）段页式：

- 先分段，每段再分页。因此每个进程只有一个段表，每个段都有一张页表
- 地址结构：段号+页号+页内偏移量



**内存映射文件**

