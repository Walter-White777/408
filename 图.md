# 图

## 基本概念

- 图不可以是空图：顶点集**一定非空**，边集可以非空
- 简单图：没有重复边；没有到自身的边
- 完全图：n(n-1)/2的无向图



## 存储结构

**1.邻接矩阵：**

- A [i] [j]表示顶点i到顶点j的路径
- 适合稠密图，稀疏图的邻接矩阵要采用**压缩矩阵**，只存储三角
- 主对角线为0；不可达为∞

**2.邻接表：**

- 顶点结点（顶点的数据&指向边表头的指针）和边结点（邻结点的数据和下一条邻结边的指针）
- 不唯一
- 无向图存储空间：|V|+2|E|;有向图：|V|+|E|

**3.十字链表：**

- 针对**有向图**
- 顶点结点和弧结点（）

**4.邻接多重表：**

- 针对**无向图**

## 图的遍历

**DFS：**

```c++
dfs(v)
{
    visit(v);
    for u in v的邻结点：
        if(!visited(u))
        	dfs(u);
}
```

- 时间复杂度：邻接表O(|V|+|E|)；邻接矩阵O(|V|^2)
- 

**BFS:**

```c++
bfs(graph,v)
{
    deque q;
    

}
```

- 时间复杂度：邻接表O(|V|+|E|)；邻接矩阵O(|V|^2)



- 基于邻接矩阵的遍历序列唯一，邻接表的遍历序列不唯一

## 图的应用

### **最小生成树(MST)：**

- 权值最小的生成树（包含所有的顶点，砍去一条边会不连通；增加一条边，会形成回路）

- 不唯一；但边的权值之和唯一

- |V|-1=|E|

- **Prim算法：**

  **集中的**

  初始挑选任意顶点加入联通分量，每次挑选于联通分量集合（与其中任意一个顶点）最短的路径。O(|V|^2)

  因此Prim算法得到的MST唯一

- **Kruskal算法：**

  **散的**

  初始每个顶点自成联通分量，每次挑选依附于不同联通分量之间的最短的边

  O(ElogE)

- **MST的唯一性：**

  如果一条边不在MST的边集中，并且可以替换与其权值相同的在MST的边集里的另一条边，则不唯一

  当连通图任意一个环的边的权值不相同时，唯一

  

  

  

  

  

  

### **最短路径：**

**Dijkstra算法：**针对**非负权图**，单源最短路径：求某一顶点到其他各顶点之间的最短路径

- 每次选择距离源点距离最近的点加入集合，再更新经过这条路径的到其它点的距离（小于就更新）

- 不能有负权值
- O(|v|^2)
- 过程：1）路径初始为start到各结点的直连长度，如果不直连，则为∞ 2）每一趟选择路径长度里最小的结点，然后更新经过该结点到其它结点的路径长度  3）**初始算第0趟**

**Floyd算法：**求任意两个顶点之间的最短路径

- O(|V|^3)



### **有向无环图表达式：**

- 给定一串表达式，按照优先级给出DAG
- 先将操作数无重复得排成一排，按照优先级给各运算符排序。排序后按照顺序添加运算符号，若有存在的可以重复利用，即可以有多个箭头指向同一个运算符结点

### **拓扑排序：**

- 针对DAG图的各节点排序问题
- 正拓扑排序（先前继，再后继）：1）选择一个没有入度的结点 2）删除该结点及其所有出度 3）重复上述操作，直到图为空 or 所有结点都有入度
- 逆拓扑排序（先后继，再前继）：与上述步骤相反
- 若一个结点有多个直接后继，则拓扑排序不唯一
- 若一个图的邻接矩阵是**三角矩阵**，则其存在拓扑序列（**充分条件**）
- 时间复杂度：1）邻接表：O(v+e) 2）邻接矩阵：O(v^2)



### **关键路径：**

- AOE网：顶点表示事件，有向边表示活动，边上的权值表示活动开销

- AOV网：顶点表示活动

- 关键路径：从开始点到结束点的**最大路径长度（即完成项目的最短时间）**的路径。关键路径可能**不唯一**，缩短工期必须缩短所有关键路径中**共有**的

  步骤：1.求出各顶点最早发生时间

  ​			2.求出最迟发生时间

  ​			3.找出所有活动（弧）最早和最迟发生时间差值=0，构成的路径即为关键路径

- 事件最早发生时间ve[i]:必须等进入i的所有活动<vk,vi>（k为i的**所有**直接前继），ve[i]=max(ve[k]+len<vk,vi>)

  ve[源点]=0

  **总结：最早发生时间=所有  入度+前一个结点最早发生时间  的最大值**

- 事件最迟发生时间vl[i]：必须等事件i发生，从其出发的所有活动<vi,vj>才能发生，活动发生，其**后继事件j**才能发生，因此vl[i]=min(vl[j]-len(vi,vj))

  vl[结束点]=ve[结束点]

  **总结：最迟发生时间=所有  后一个结点的最迟发生时间-出度  的最小值**

- 活动最早发生时间ee[i]：事件i发生后，活动<vi,vj>才能发生，因此活动发生的最早时间=事件i(**即有向边的起点**)发生的时间ee[i]=ve[i]

  **总结：最早发生时间=弧的起点的最早发生时间**

- 活动最迟发生时间el[i]：与上同理，活动<vi,vj>发生的最迟时间=事件i的最迟发生时间，el[i]=vl[j]-len(<vi,vj>)；

  **注：最迟发生时间=终点的最迟发生时间-弧长**
  
  **注：活动是有方向的，要用指向的事件的最迟发生时间-活动时间**

