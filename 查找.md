# 查找

**平均查找长度ASL：**

- 查找所有元素需要**比较的次数**的平均值
- 成功平均查找长度
- 失败平均查找长度

## 线性结构

### 1.顺寻查找

- 顺序or链式存储都可以
- 线性链表只能用顺序查找
- 有序表的顺序查找：



### 2.二分查找

- 只适用于有序的顺序存储表
- 成功ASL=n+1/n*log2(n+1)-1~log2(n+1)-1
- 二分查找判定树一定为一个平衡二叉树，low和high结点相加/2是向上取整or向下取整**要统一**
- O（log2n）

### 3.分块查找







## 树形查找

### 1.二叉搜索树BST（二叉排序树）

- **空树**可以是BST；

- 非空时：**左子树**上的所有节点的值**小于**根节点的值，**右子树**上的所有结点的值**大于**根节点的值

- 查找的过程类似二分查找的查找判定树

- **插入**的结点一定变成BST中的一个**叶结点**

- 删除：1）叶子结点直接删除 

  ​			2）只有一个子树，直接将其接到删除结点的父节点上  

  ​			3）有两个子树，用其左子树的最大值or右子树的最小值代替它，然后再调整子树的结构

  删除某结点后重新插入该结点，与原树是否相同？**答：可能相同，也可能不同**

- O(log2n)

- 查找效率取决于树的高度：左右是否均衡or 单链表形式

- 最坏情况：每个结点只有左子树or右子树，这样就退化成了链表。从而引出AVL

### 2.二叉平衡树AVL

- 各节点的左子树和右子树的**高度差**的绝对值<=1，高度差也成为该节点的平衡因子
- 满足BST的性质：中序遍历为有序序列
- 调整对象：离插入结点最近的平衡因子大于1的结点
- 选择哪种旋：看插入结点是在要调整结点的哪边孩子的哪边子树。例如插入结点在调整结点的右孩子的左子树上，就将调整结点的**右孩子的左子树的根节点**先右旋再左旋
- 深度为h的AVL的**最少结点数**nh=nh-1+nh-2+1，即为每个非叶结点的平衡因子都为1的情况

### 3.红黑树

- 自平衡BST

- 根节点、叶结点（即虚构的NULL结点）为黑；

- 红结点的子结点和父结点为黑

- 任意结点到叶结点的路径上所经的黑结点数量相同：

  1）到叶子结点的最长路径<=最短路径*2

  2）h<=2log2(n+1)

- 适合插入和删除频繁、查找较少的操作

- 插入：新插入的结点为红色

  当插入结点的父结点为红色时，祖父结点必为黑色：

  1）当叔叔结点为红色时，则将三个结点（祖、父、叔）都变色，若此时祖父结点是作为根节点，则需要将祖父结点变黑，就会出现连续的两个黑色（唯一增加连续黑色层数的情况）

  2）当叔叔结点为黑色or不存在时

![img](https://upload-images.jianshu.io/upload_images/2392382-ab4097b750826870.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)

![img](https://upload-images.jianshu.io/upload_images/2392382-fbfc4f299941cb8b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

- 删除

### 4.B树

- 自平衡多路BST

- m阶B树：

  一个内部结点**最多**有m个子结点，m-1个关键字

  除根结点外的非叶结点**至少**有m/2（向上取整）棵子树，即**至少**有m/2-1个关键字

- h∈[logm(n+1),log(m/2)（n+1/2）+1]，磁盘存取次数

- 插入操作，当一个结点的关键字数=m时，将**第m/2个（向上整除）**关键字放到该节点的父结点中，左右两个结点**分裂**

- 删除操作：当删除某个结点后，兄弟结点和父结点没有可以借的，则父结点要和兄弟结点合并，父结点就空了出来

### 5.B+树

- 各关键字对应一棵子树，比B树少一棵
- 每个结点最少有m/2个关键字，最多有m个，比B树多1
- 叶节点中有信息，且叶结点包含了所有关键字；B树叶结点和非叶结点的关键字不重复
- 查找比B树多一种**顺序查找**，**共有**的是多路查找
- 应用于数据库，文件系统索引

## 哈希表

### 1.散列函数：

- 线性函数直接定址
- 模p



### 2.处理冲突

**1）开放地址法**

- (H(key)+di)%m，m为散列表表长

如何选择di:

- 线性探测：di由0开始递增，会造成聚集现象
- 平方探测：di=0，1^2,-1^2,2^2,...k^2,-k^2
- 双散列：di=i*Hash2(key)

**2）拉链法**

- 把所有有冲突的关键字存储到一个线性链表，下标为其散列地址

**3）查找性能**

- ASL（平均查找长度）=（总比较次数）/n；n为元素个数

  查找成功长度：

  查找失败长度：映射到0—key-1的位置，各个位置往右到第一个空的位置（整个散列表范围内）的比较次数即为失败的比较次数

- 装填因子：非空记录数/散列表长度。ASL依赖于装填因子，装填因子越大，表越满，越容易发生冲突

- 影响**查找速度**的因素：散列函数、处理冲突方法、装填因子

