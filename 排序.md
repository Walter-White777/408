# 排序

## 内部排序

|          | 时间复杂度      | 空间复杂度 | 稳定性 | 比较次数 | 初始状态 | 适用性       |
| -------- | --------------- | ---------- | ------ | -------- | -------- | ------------ |
| 插入排序 | O(n^2)          | O(1)       | 1      |          |          |              |
| 冒泡排序 | O(n^2)          | O(1)       | 1      | 最坏n-1  |          |              |
| 选择排序 | O(n^2)          | O(1)       | 0      | n(n-1)/2 |          |              |
| 希尔排序 | O(n^1.3)        | O(1)       | 0      |          |          | 仅顺序存储   |
| 快速排序 | O(n^2)/O(nlogn) | O(logn)    | 0      |          | 有关     | 适合顺序存储 |
| 堆排序   | O(nlogn)        | O(1)       | 0      |          |          | 关键字比较多 |
| 归并排序 | O(nlogn)        | O(n)       | 1      |          |          |              |
| 基数排序 |                 |            | 1      |          |          |              |



**简单选择排序：**



**插入排序：**



**堆排序：**

- 插入：插在最后一个，向上调整
- 删除：删除堆顶元素，将最后一个元素放到堆顶，向下调整
- 所有根比下面**所有子树**小或者大的数组
- 交换后可能会破坏下一级的堆,要继续调整

**希尔排序：**

- 间隔=相邻比较的数下标之差
- 希尔排序内部采用直接插入排序



**归并排序：**

- 将两个及以上的**有序表**合并大有序表
- 

**基数排序：**

- 从最右边一位开始，进行比较，分别稳定排序。不改变相对顺序

**冒泡排序：**

- 升序的情况：从前往后两两比较，如果前大后小，则交换
- 每一趟都有一个大的数放到最后面

## 外部排序

- 针对**大文件**，需要进行多次IO，采用**归并排序**

- 过程：首先将文件分为长度相等的子文件，依次将其读入内存用内部排序进行排序；

  ​			然后将这些子文件重新写回外存，称为归并段

  ​			最后将归并段逐趟归并，使归并段由小到大

- 多路平衡归并：互相比较的归并段数

- 最佳归并：确定归并段的归并顺序，从而使IO次数最少

  ​					利用哈夫曼树，推广到m叉树的情况

  ​					又 初始归并段的数量不足以构成严格的m叉树，因此需要添加**虚段**

  **虚段数=m-(n-1)%(m-1)-1,n为归并段的数量，即度为0的结点**



- 时间复杂度：IO次数