# 进程管理

## 进程与线程

### 1.进程

PCB是进程存在的唯一标志。进程是进程实体（包括数据、程序、PCB）运行的**过程（动态）**

**（1）进程状态**

​                  ![img](https://img-blog.csdnimg.cn/2019110110291543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NjY2ODU3,size_16,color_FFFFFF,t_70)

**事件发生**指事件到来（如IO结束 or 中断结束）

**等待事件**指请求资源时（IO or 外设）



- 唤醒：阻塞--->就绪
- 休眠：运行---》阻塞
- 睡眠恢复**自动**完成，因为睡眠有睡眠时间，只要某事件完成or获得资源就自动唤醒
- 挂起恢复需要主动完成

---

**（2）进程组织**

**PCB：**放在OS内核中，常驻内存。

内容：

+ PID(唯一)
+ 优先级
+ 资源分配清单（指针、堆栈）
+ 上下文：处理机中各寄存器的值
+ 程序段：程序可以被多个进程共享

**PCB的组织方式：**

- 链接成队列：不同状态的进程处于不同队列
- 索引表：将同一状态的进程放在一张索引表中

**注：程序段可以被多个进程共享**

---

**（3）进程控制**

控制进程的程序称为**原语**，不可中断

**进程创建：**

进程在执行时可能创建多个新进程，形成进程树

（用户登录，作业调度，用户程序的应用请求）->进程创建（可由其父进程创建）：

1.分配pid，空pcb

2.从**os  or 父进程**分配资源（处理机、内存、文件、IO设备）

​	父进程分配资源时，限制子进程只能使用父进程的资源，从而防止创建过多进程，导致系统超载

3.初始化pcb

4.插入就绪队列

**注：父进程和子进程的问题：**

- 父进程和子进程共享一部分资源
- 父进程可能向子进程传递初始化数据
- 父进程创建子进程后，子进程一定执行
- 子进程可能是父进程的复制品（相同程序和数据）；也可能是另一个新程序



**进程终止：**

- 进程终止时，OS会释放资源，但位于进程表中的条目还在，直到其父进程调用wait()，该僵尸进程在进程表中的条目会被释放

**（4）进程通信**

**1.共享空间：**进程之间通过**系统调用**访问公用存储空间，因为进程运行期间不能访问其它进程空间



**2.消息传递：**使用发送和接收消息原语进行数据交换

- 直接通信：将发送的信息挂载到接收进程的消息缓冲队列上，接收进程从队列中获取
- 间接通信：信箱



**3.管道通信：**管道是一个大小为4KB（Linux中）的在磁盘中的文件，采用**半双工**通信

可以有两个及以上的进程对其操作：一边写，另一边读

### 2.线程

为什么要引入线程：多进程并发时，进程切换频繁，上下文切换也很频繁，导致资源消耗较大，同时也限制了并发的进程数。

使线程成为了被调度和分派的基本单位，**只拥有**堆栈、cpu现场等资源；

可以共享进程的所有系统资源（包括线程），因此线程可以访问本进程内的其它线程的资源

**注：线程中区别堆栈和堆栈指针，堆栈是线程所有的资源，堆栈指针是线程控制块中的内容。因此线程的堆栈是可以被其它线程访问，但是堆栈指针不行**

同个进程内的线程的切换很快

系统线程一旦被创建，就会一直运行而不会终止

**线程的控制：**线程被终止后并不立即释放资源，只有当进程中其它线程执行了分离函数后，被终止线程才与资源分离；

终止但尚未释放资源的线程仍然可以被调用，可以重新恢复

**（1）用户级线程**

- in 用户空间
- 无需内核支持切换线程
- 以进程为单位进行调度（调度时，一个进程会获得一个时间片）
- 进程中的线程执行系统调用时，进程中的其它线程**都会**阻塞



**（2）内核级线程**

- 内核支持，以线程为单位调度（调度时，每个线程都会获得处理机时间片）

- 同一进程线程切换需要内核，速度低下



**（3）多线程模型**

- 多对一：将多个用户级线程（同属一个进程）映射到一个内核级线程，仅当用户线程需要访问内核时，每次只允许一个线程进行映射。

  当一个线程访问内核时被阻塞时，整个进程都会被阻塞

- 一对一：将每个用户级线程映射到一个内核级线程

- 多对多：用户级线程的数量>=内核级线程的数量





| 性质 | 进程 | 线程 |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

## CPU调度

### 1.三种调度类型

**（1）高级调度**

aka作业调度。从外存中选择一个（or多个）作业，分配资源，并建立进程。挂到就绪队列中

**（2）低级调度**

aka进程调度。将处理机分配给有资格的进程。频率很高。

**注：进程调度时，当前进程的上下文保存到其PCB中，处理机要运行分派程序，因此寄存器装入分派程序的上下文；分派程序执行完之后，移除其上下文，将新的进程的上下文装入各寄存器**；

由于上下文的频繁切换，要用load/store指令，因此耗时较多

****

**（3）中级调度**

内外存之间的进程对换，从而降低内存中的进程数量；

然后，被换出的进程可以重新调入内存，并从中处继续执行。称为**交换**

### 2.调度算法

调度指标：

- 等待时间：提交~获得处理机的时间
- 平均周转时间：提交~运行完的时间
- 平均带权周转时间：周转时间/运行的时间

#### 1.FCFS

不利于后面到达的短作业

有利于CPU繁忙型作业（用CPU用的多，IO少），不利于I/O繁忙型

#### 2.SJF

若某个时刻只有一个作业or进程，则选择其进行调度

- 长作业长期不被调度（饥饿现象）
- 按照作业的估计运行时间，存在误差
- 平均等待时间、平均周转时间最少

#### 3.优先级

- 系统进程>用户进程
- 前台进程>后台
- I/O>计算型：I/O比较慢，让IO设备早点开始工作

静态优先级中，低优先级进程可能长期得不到调度，也造成饥饿现象

#### 4.高响应比

响应比=1+等待时间/要求服务时间

- 对于长作业，随等待时间的增加，响应比增加，优先级提高，克服了饥饿现象
- 短作业优先

#### 5.时间片轮转

按FCFS排队，每个进程运行一个时间片后，强制被剥夺下来，放到就绪队列的队尾

如何选择时间片的大小很重要！！

- 系统响应时间
- 进程数目
- 处理机处理能力

#### 6.多级反馈队列

- 各队列优先级不同
- 各队列时间片不同
- 各队列内部采用FCFS，最后一级队列采用时间片轮转调度
- 只有当上一级的队列为空时，下一级队列才会开始调度

#### 

### 3.调度实现

**1）调度器（调度程序）**

- 排队器：每当有进程转为就绪状态时，排队器将其插入到响应就绪队列中

- 分派器：CPU分配给选中进程

- 上下文切换器：将当前进程上下文保存到PCB中，再装入分派程序的上下文；将分派程序的上下文移出，将新进程的CPU现场信息装入各寄存器

  需要执行大量load/store指令，来保存寄存器内容。通过硬件方法解决：用两组寄存器，一个供内核，一个供用户，不同进程切换时，只需要改变指针指向不同的寄存器即可

**2）调度时机**

**不能进行进程调度和切换的情况：**

- 处理机在执行中断处理程序的**过程中**：中断处理不属于某个进程
- **进程访问OS内核临界区时**：一般是访问OS内核的数据结构，如就绪队列，**注意**和一般的访问临界区进行区别
- 原子操作

**需要进行调度的情况：**

- 中断处理结束or自陷处理结束，返回被中断的用户程序，**即核心态返回用户态时**
- 创建一个新进程之后
- 一个进程结束时
- 中断**发生时

**3）调度方式**

- 非抢占
- 抢占

**4）闲逛进程**

- 只需要CPU，其它资源不需要，因此**不会阻塞**
- 进程切换时，没有就绪进程时的**万金油**；
- 会一直运行，并会测试中断，**直到**有就绪进程，就让出处理机

**5）线程调度**

**1）用户级线程**

- OS给进程时间控制

- 由进程中的调度程序决定哪个线程运行

**2）内核级线程**

- 内核选择一个线程赋予时间片，超过就强制挂起

### 4.上下文及其切换机制

**上下文：**

- CPU寄存器的值
- 进程状态
- 内存管理信息

**上下文切换：**

- 切换时间因机器而异，与内存速度、目标寄存器数量、是否有特殊指令有关

## 同步&互斥

**临界区：**指访问临界资源的**代码**

同步的原则：

- 空闲让进：临界区空闲时，允许请求的进程进入

- 忙则等待：临界区有进程时，其它请求进程要等待

- 有限等待：请求临界区的进程可以在有限时间内进入

- 让权等待：进程不能进入临界区时，立即释放CPU

  **注：让权等待不一定要实现**

### 1.实现临界区互斥的方法

#### （1）软件



- 皮特尔森算法：

  flag[i],turn=j;

  while(flag[j]&&turn==j)

  解决了饥饿现象；没有实现让权等待：会一直在循环中，没有释放处理机

#### （2）硬件

- 中断屏蔽：cpu只在发生中断时引起进程切换，关中断后就不会响应中断 ；不能将开关中断指令交给用户，若关中断之后忘记了开中断，则系统终止

- 硬件指令： TestAndSet（原子操作，不允许中断）&swap
- 适用于任意数目进程，但**不能实现让权等待，从而导致饥饿**



### 2.信号量机制

信号量实现了让权等待

（1）整型信号量

- 没有实现让权等待



（2）记录型信号量

- S.value<0时，|S.value|=阻塞队列中等待该资源的进程数
- S.value>=0时，表示资源的剩余数量，没有进程在等待该资源
- wake后，若S.value<=0,说明还有进程在阻塞队列中
- S.value的表示范围[x-n,x],x为其初值
- 阻塞队列中最多有n个进程（即发生了死锁）；就绪队列中最多有n-1个进程，因为处理机上一定有一个
- 信号量<0时，调用block原语进行自我阻塞，因此**实现了让权等待**



### 3.管程

- 定义：共享数据结构+对共享数据结构的操作过程   的**资源管理程序**
- 每次仅允许一个进程进入管程 ，因此**默认**实现了互斥

- 实现同步，性质默认了互斥

**条件变量**：阻塞原因

- 多个条件变量，每个都保存了一个等待队列

- x.wait():不满足x条件时，进程将自己加入等待队列（阻塞进程），并释放管程
- x.signal():唤醒一个因x条件而阻塞的进程
- 没有值，**仅**实现了排队等待功能



### 4.同步问题

1）分析不同对象之间的关系：是同步还是互斥，要看进程中**是否修改了共享资源的值**，如果只是调用而并没有修改值，不用加互斥；如果修改了共享资源的值，则要与使用该共享资源的进程互相互斥

2）分析资源的数量：

3）确定信号量的初值



### 5.锁

- acquire()和release() ，原子操作，采用硬件机制来实现
- 缺点：忙等待
- 适用于多处理器系统





**前驱问题：**





（1）生产者-消费者问题



（2）读-写问题

允许多个读者读，写者写时，其它读写者均不能访问

- 写者写时，要与其它写者互斥，因此mutex=1

- 写者，读者也不能读，因此也用到mutex;

- 当有读者在访问时，说明肯定没有写者在写；当没有读者在访问时，简化为简单的互斥问题。因此设置一个整数readcount记录访问读者的数量，当为0时，要wait(mutex)；不为0时，++

  注意，readcount也是临界资源，因此需要对其进行互斥wait（rmutex）



（3）哲学家进餐问题



## 死锁

- 死锁预防：破坏4个必要条件（互斥（不可能），请求和保持，不剥夺，环路等待），四个条件同时满足才是死锁状态

  破坏请求和保持：一次就申请所有资源

  破坏环路等待：按顺序请求资源

- 死锁避免：银行家算法

安全性算法表：

|      | Work | Need | Allocation | W+A  |
| ---- | ---- | ---- | ---------- | ---- |
| P1   |      |      |            |      |
| P2   |      |      |            |      |
| ...  |      |      |            |      |
| Pn   |      |      |            |      |

Work初始值为Available，Need表示还需要的资源的数量，Allocation表示已经分配的资源

**注：安全性算法可以检测此时系统是否处于安全状态，而不是死锁状态**

死锁避免限制了**进程的运行顺序**，而非进程申请资源的顺序

- 死锁检测：资源分配图和死锁定理

找出一个非阻塞非孤立（有边与其相连&对应资源的申请数量<=其空闲数量）的结点，删除其所有相连的边

循环上述操作

最后全是孤立结点，则无死锁；反之，则有

- 死锁解除：资源剥夺、撤销进程、进程回退

